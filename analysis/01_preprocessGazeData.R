##############################################
#Functions for processing gaze data output of
#pygaze 0.7.6 experiment (.tsv file)
#############################################

#' The .tsv file output in pygaze contains gaze data info as well event data logged during the experiment.

#' The following columns are generated by the tobii_research/pygaze package:
#'  TimeStamp          Event              
#'  GazePointXLeft     GazePointYLeft     ValidityLeft       
#'  GazePointXRight    GazePointYRight    ValidityRight    
#'  GazePointX         GazePointY         
#'  PupilSizeLeft      PupilValidityLeft  
#'  PupilSizeRight     PupilValidityRight
#'
#' We extract the following columns:
#' TimeStamp        Event 
#' GazePointXLeft   GazePointYLeft  
#' GazePointXRight  GazePointYRight 
#' GazePointX       GazePointY
#' 
#' Once these column values are loaded, we make the following modifications:
#' 1. Gaze measurements with ValidityLeft or ValidityRight that are greater than 1
#' 2. XY Gaze values that fall outside the set screen size are invalid and should be discarded
#' 3. Recode values <1 as NA
#' 4. Flip the Y-axis of the screen so it is in the bottom left instead of top left
#' 
#' We also extract the information in the Event columns (participant and trial information)
#' 
#' The final dataset should include the following columns:
#' Experiment ParticipantID  trialOrder trialType  trialID (for merging with trial order csv)


integrateEventData <- function(filename, skipnum = 7){
  # read raw csv for Tobii output
  print(filename)
  d_raw_gaze <- read.csv(filename, sep="\t", skip = skipnum)
  d_raw_gaze <- d_raw_gaze |> select(TimeStamp, Event, 
                                     GazePointXLeft, GazePointYLeft, ValidityLeft, 
                                     GazePointXRight, GazePointYRight, ValidityRight,
                                     GazePointX, GazePointY)
  d_raw_gaze$TimeStamp_num <- as.numeric(d_raw_gaze$TimeStamp)
  #select rows with trial information
  d_trial_info <- d_raw_gaze |> 
    filter(grepl("Experiment", d_raw_gaze$Event)) |> 
    select(TimeStamp, Event) |> 
    # separate the event data into a list column
    mutate(values = strsplit(Event, " ")) |> 
    # unnest to create a row for each event entry
    unnest(values)
  
  
  # The events and event names are every other row, so need to align them so I can pivot.
  event_names = d_trial_info$values
  event_names[c(FALSE, TRUE)] <- NA #replace the non-event name entries
  d_trial_info$names = append(NA, event_names[-length(event_names)])
  
  d_trial_data_wider <- d_trial_info |> 
    filter(!is.na(names)) |>  #drop the filler NA rows
    mutate(names = ifelse(names == "TrialType", "trialType", names)) |> 
    pivot_wider(names_from = names, values_from = values)
  
  d_trial_data_wider$trial_number <- seq(1, nrow(d_trial_data_wider))
  
  d_full <- d_raw_gaze |> 
    #create the corresponding unique trial ID with cumsum
    mutate(trial_number = cumsum(grepl("Experiment", d_raw_gaze$Event)),
           participant_group = str_split(filename, "/")[[1]][8]) |> 
    left_join(d_trial_data_wider |> 
                select(-Event, -TimeStamp), 
              by = join_by(trial_number)) |> 
    filter(!is.na(Experiment))  # Drop looks before pygaze begins experiment
  
  d_full[d_full=="None"]<-NA
  
  d_full <- janitor::remove_empty(d_full, which = "cols") # drop completely empty columns introduced by trial order weirdness
  
  return(d_full)
}

processGazeData <- function(gazedata, monitor_x = 1024, monitor_y = 768){
  
  
  # Flip Y- Axis
  gazedata$GazePointY <- monitor_y - gazedata$GazePointY
  gazedata$GazePointYLeft <- monitor_y - gazedata$GazePointYLeft
  gazedata$GazePointYRight <- monitor_y - gazedata$GazePointYRight
  
  # TODO: Replace any looks with a validity >= 2 (re tobii documentation)
  #invalid_L <- which(2 <= gazedata$ValidityLeft)
  #invalid_R <- which(2 <= gazedata$ValidityRight)
  #print(colnames(gazedata))
  #gazedata[invalid_L, GazePointXLeft] <- NA
  #gazedata[invalid_L, GazePointYLeft] <- NA
  #gazedata[invalid_R, GazePointYRight] <- NA
  #gazedata[invalid_R, GazePointXRight] <- NA
  
  CorrectInvalidGazes <- function(gaze, gaze_max){
    gaze[(gaze < 0)] <- NA #replace off screen/no looks aka -1 with NA
    gaze[(gaze > gaze_max)] <- NA #replace off screen with NA
    return(gaze)
  }
  
  gazedata <- within(gazedata, {
    GazePointXLeft <- CorrectInvalidGazes(GazePointXLeft, gaze_max = monitor_x)
    GazePointXRight <- CorrectInvalidGazes(GazePointXRight, gaze_max = monitor_x)
    GazePointYLeft <- CorrectInvalidGazes(GazePointYLeft, gaze_max = monitor_y)
    GazePointYRight <- CorrectInvalidGazes(GazePointYRight, gaze_max = monitor_y)
    GazePointX <- CorrectInvalidGazes(GazePointX, gaze_max = monitor_x)
    GazePointY <- CorrectInvalidGazes(GazePointY, gaze_max = monitor_y)
  })
  
  # A "monocular mean" averages both eyes together. If data is available in just
  # one eye, use the available value as the mean.
  
  ComputePairMeans <- function(x1, x2) {
    xm <- rowMeans(cbind(x1, x2), na.rm = TRUE)
    # NaN => NA
    ifelse(is.nan(xm), NA, xm)
  }
  
  gazedata <- within(gazedata, {
    GazePointXMean <- ComputePairMeans(GazePointXLeft, GazePointXRight)
    GazePointYMean <- ComputePairMeans(GazePointYLeft, GazePointYRight)
  })
  
  #add column that tracks whether a full look (X and Y coordinate) was tracked
  gazedata$isLook=ifelse(is.na(gazedata$GazePointX)|is.na(gazedata$GazePointY),NA,1)
  
  return(gazedata)
}




assignAOI <- function(gazedata, aoi_coordinates, aoi_label){
  gazedata |> 
    mutate(LookAOI = case_when(GazePointXMean > aoi_coordinates[[1]][[1]] & 
                             GazePointXMean < aoi_coordinates[[1]][[2]] & 
                             GazePointYMean > aoi_coordinates[[2]][[1]] &
                             GazePointYMean < aoi_coordinates[[2]][[2]] ~ aoi_label,
                             LookAOI != "to_fill" ~ LookAOI, 
                     TRUE ~ "to_fill"))
}

normalizeTimeMS=function(gazedata){
  normalized_time <- gazedata |> 
    mutate(trial_start_timestamp = ifelse(grepl("Experiment", gazedata$Event), 
                                          TimeStamp, 
                                          NA)) |> 
    fill(trial_start_timestamp) |> 
    mutate(normalizedTimeStamp = TimeStamp - trial_start_timestamp) |> 
    select(TimeStamp, normalizedTimeStamp, everything(), -trial_start_timestamp)
  
  return(normalized_time)
}


rezeroTrials <- function(df_trial){
  startScreenTimepoint <- df_trial |> filter(Event == "startScreen") |> pull(normalizedTimeStamp)
  df_trial <- df_trial |> 
    mutate(TimeStampRezeroed = normalizedTimeStamp - startScreenTimepoint) 
  df_trial |> select(TimeStamp, normalizedTimeStamp, TimeStampRezeroed, everything())
}


createTimeBins=function(gazedata,ms_per_frame=1000/60) {
  #Bin TimeStamps with slight ms level variations on different trials into time bins
  gazedata$TimeBin=round(gazedata$TimeStampRezeroed/ms_per_frame,0)
  
  #Create ms equivalents of time bins
  gazedata$TimeBinMs=gazedata$TimeBin*ms_per_frame
  
  # create skeleton dataframe to generate missing rows
  gazedata_skeleton = tibble(TimeBin = seq(min(gazedata$TimeBin), max(gazedata$TimeBin)+1)) 
  gazedata_skeleton$TimeBinMs=gazedata_skeleton$TimeBin*ms_per_frame
  
  gazedata_skeleton |> left_join(gazedata |> select(TimeStampRezeroed, TimeBin, TimeBinMs, everything()), by = join_by(TimeBin, TimeBinMs))
}

